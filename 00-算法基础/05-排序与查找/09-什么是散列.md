# 什么是散列

## 散列 Hashing

- 如果数据项之间是按照**大小排好序**的话，就可以利用**二分查找**来降低算法复杂度
- 构造一个新的数据结构，能使得查找算法的复杂度降到**O(1)**，这种概念称为**散列 Hashing**
- 能够使得查找的次数降低到**常数级别**，我们对数据项所处的位置就必须有更多的**先验知识**
- 如果我们**事先**能知道要找的数据项**应该**出现在数据集中的什么**位置**，就可以直接到那个位置看看数据项是否存在即可
- 由数据项的**值**来确定其**存放位置**

---

## 关于散列的基本概念

- **散列表**（Hash Table，又称哈希表）是一种数据集，其中数据项的存储方式尤其有利于将来快速的查找定位
- 散列表中的每一个存储位置，称为**槽**（Slot），可以用来保存数据项，每个槽有一个唯一的名称
- 实现从数据项到存储槽名称的转换的，称为**散列函数**（Hash Function）
- 有一种常用的散列方法是**求余数**，将数据项除以散列表的大小，得到的余数作为槽号
- 槽被数据项占据的比例称为散列表的**负载因子**
- 不过，会出现几个值被分配到同一个槽中，这种情况称为**冲突collision**

---

## 完美散列函数

- 给定一组数据项，如果一个散列函数能把每个数据项映射到不同的槽中，那么这个散列函数就可以称为**完美散列函数**
- 获得完美散列函数的一种方法是扩大散列表的容量
  - 大到**所有可能出现**的数据项都能够占据不同的槽
  - 但这种方法对于可能数据项范围过大的情况并不实用
  - 退而求其次，好的散列函数需要具备特性: 
    1. 冲突最少（近似完美）
    2. 计算难度低（额外开销小）
    3. 充分分散数据项（节约空间）

---

## 指纹函数

- 散列技术还用在信息处理的很多领域
- 由于完美散列函数能够对任何不同的数据生成不同的散列值， 如果把散列值当作数据的“指纹”或者“摘要”，这种特性被广泛应用在数据的一致性校验上
- 作为一致性校验的数据“指纹”函数需要具备如下的特性
  - **压缩性**：任意长度的数据，得到的“指纹”长度是固定的
  - **易计算性**：从原数据计算“指纹”很容易（从指纹计算原数据是不可能的）
  - **抗修改性**：对原数据的微小变动，都会引起“指纹”的大改变
  - **抗冲突性**：已知原数据和“指纹”，要找到相同指纹的数据（伪造）是非常困难的

---

## 散列函数 MD5/SHA

- 最著名的近似完美散列函数是 MD5 和 SHA 系列函数
- MD5（Message Digest） 将任何长度的数据变换为固定长为128位（16字节）的“摘要”
- SHA（Secure Hash Algorithm）是另一组散列函数
  - SHA-0/SHA-1输出散列值160位（20字节）
  - SHA-256/SHA-224分别输出256位、224位
  - SHA-512/SHA-384分别输出512位和384位
- 近年发现MD5/SHA-0/SHA-1三种散列函数，能够以极特殊的情况来构造个别碰撞（散列冲突），但在实用中从未有实际的威胁

---

## 散列函数设计

1. 折叠法
   - 将数据项按照位数分为若干段，再将几段数字相加，最后对散列表大小求余，得到散列值
   - 有时候折叠法还会包括一个**隔数反转**的步骤
   - 虽然隔数反转从理论上看来毫无必要，但这个步骤确实为折叠法得到散列函数提供了一种**微调**手段，以便更好符合散列特性
   
2. 平方取中法
   - 首先将数据项做平方运算，然后取平方数的中间两位，再对散列表的大小求余
   - 平方取中法计算量稍大

3. 非数项散列
   - 我们也可以对非数字的数据项进行散列，把字符串中的每个字符看作ASCII码即可
   - 将这些整数累加，再对散列表大小求余
   - 为了防止散列函数对所有的变位词都返回相同的散列值，可以将字符串所在的位置作为权重因子，乘以ord值

4. 散列函数设计原则
   - 散列函数不能成为存储过程和查找过程的计算负担
   - 如果散列函数设计太过复杂，去花费大量的计算资源计算槽号可能还不如简单地进行顺序查找或者二分查找
   - 太过复杂的散列函数就失去了散列本身的意义

